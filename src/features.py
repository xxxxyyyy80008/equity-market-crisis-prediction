import pandas as pd
import numpy as np
from typing import List, Optional

class FeatureEngineer:
    """
    Handles feature generation for financial time series data.
    Generates technical indicators, rolling statistics, and target labels.
    """
    
    def __init__(self, windows: List[int] = [5, 10, 21, 63]):
        """
        Args:
            windows: List of window sizes for rolling calculations (e.g., [Week, 2-Weeks, Month, Quarter]).
        """
        self.windows = windows

    def calculate_returns(self, df: pd.DataFrame, price_col: str = 'Close') -> pd.DataFrame:
        """Calculates simple and log returns."""
        df = df.copy()
        df['Log_Ret'] = np.log(df[price_col] / df[price_col].shift(1))
        return df

    def calculate_volatility(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculates rolling volatility (standard deviation of returns)."""
        for w in self.windows:
            df[f'Vol_{w}d'] = df['Log_Ret'].rolling(window=w).std() * np.sqrt(252)
        return df

    def calculate_momentum(self, df: pd.DataFrame, price_col: str = 'Close') -> pd.DataFrame:
        """Calculates momentum indicators like RSI and Rate of Change."""
        # Rate of Change
        for w in self.windows:
            df[f'ROC_{w}d'] = df[price_col].pct_change(periods=w)
            
        # Simple RSI Implementation
        delta = df[price_col].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['RSI_14'] = 100 - (100 / (1 + rs))
        
        return df

    def calculate_trend(self, df: pd.DataFrame, price_col: str = 'Close') -> pd.DataFrame:
        """Calculates trend indicators like Moving Averages and distances from MA."""
        for w in self.windows:
            ma_col = f'SMA_{w}'
            df[ma_col] = df[price_col].rolling(window=w).mean()
            # Distance from MA (normalized)
            df[f'Dist_SMA_{w}'] = (df[price_col] - df[ma_col]) / df[ma_col]
        return df

    def create_target(self, df: pd.DataFrame, 
                     forward_window: int = 20, 
                     drop_threshold: float = -0.10) -> pd.DataFrame:
        """
        Creates the target variable 'Is_Crisis'.
        
        Definition: A crisis is flagged if the cumulative return over the 
        NEXT 'forward_window' days is less than 'drop_threshold'.
        
        Args:
            forward_window: Number of days to look ahead.
            drop_threshold: The negative return threshold (e.g., -0.10 for -10%).
        """
        # Calculate forward looking cumulative returns
        indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=forward_window)
        df['Fwd_Ret'] = df['Log_Ret'].rolling(window=indexer).sum()
        
        # Create binary target
        df['Is_Crisis'] = (df['Fwd_Ret'] < drop_threshold).astype(int)
        
        # Shift to align features with target (Target is already forward looking, 
        # but we need to ensure we don't use future data in features. 
        # The 'Fwd_Ret' calculation effectively peeks ahead, so 'Is_Crisis' at index t 
        # represents the outcome starting from t.
        
        return df

    def process_all(self, df: pd.DataFrame, price_col: str = 'Close') -> pd.DataFrame:
        """Runs the full feature engineering pipeline."""
        df = self.calculate_returns(df, price_col)
        df = self.calculate_volatility(df)
        df = self.calculate_momentum(df, price_col)
        df = self.calculate_trend(df, price_col)
        
        # Drop NaN values generated by rolling windows
        df.dropna(inplace=True)
        
        return df

if __name__ == "__main__":
    # Test stub
    dates = pd.date_range(start='2020-01-01', periods=200)
    data = pd.DataFrame({
        'Close': np.random.normal(100, 5, 200).cumsum() + 100
    }, index=dates)
    
    fe = FeatureEngineer()
    processed_data = fe.process_all(data)
    processed_data = fe.create_target(processed_data)
    
    print(f"Features generated: {processed_data.shape,[object Object],}")
    print(processed_data.head())